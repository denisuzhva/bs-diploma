\section{Разработка генератора событий}
\subsection{План разработки и расчётов}
Для реализации генератора решено использовать объектно-ориентированный подход с целью обеспечить удобство дальнейших усовершенствований программы. В самой программе первоначально генерируется некоторое количество поперечных сечений струн в виде кругов фиксированного радиуса по заданному распределению (радиус струн соответствует параметрам распределения пропорционально реальному масштабу), затем производятся необходимые расчёты. Принципиальная схема работы программы представлена на рис. \ref{fig:DevSch} в приложении. Также в приложении (рис. \ref{fig:Strings}) представлена визуализация генерируемых струн. 

Для расчёта корреляций множественности и поперечного импульса адронов в переднем и заднем быстротных окнах (всюду далее величина корреляционного коэффицента будет обозначаться как $b$) необходимо сгенерировать соответственно значения множественности $n$ по сгенерированным струнами и значения поперечного имульса $p_t$ по струнной конфигурации и полученным значениям множественности. В качестве реализации учёта эффекта слияния струн $n$ и $p_t$ рассчитывается из плотности наложения (пересечения) струн друг на друга подсчётом количества струн в отдельно взятом кластере, а также подсчётом поперечной площади данного кластера (как наиболее физичное далее рассматриваться будет только глобальное слияние). 

Таким образом, разработка генератора разбивается на четыре этапа в порядке возрастания сложности, причём каждый следующий этап нуждается в завершённости предыдущих:
\begin{enumerate}[label=\arabic*.]
\item	Генерация струн..
\item	Поиск кластеров.
	\begin{enumerate}
	\item	Подсчёт количества струн в каждом кластере.
	\item	Вычисление площади каждого кластера.
	\end{enumerate}
\item	Генерация значений множественности и поперечного импульса.
\item	Расчёт FB корреляций множественности и поперечного импульса.
\end{enumerate}
%%%
\subsection{Выбор среды разработки}
Первоначально в качестве языка разработки был выбран MATLAB как очень удобный инструмент для быстрой и качественной реализации вычислительных алгоритмов. С помощью MATLAB были преодолены первые два этапа разработки, пока не был выявлен существенный недостаток данного решения -- слишком невысокая скорость расчётов по сравнению с более низкоуровневыми языками программирования, такими как C++ (приблизительно в 15-25 раз медленнее). На последнем впоследствии было заострено внимание, и далее было принято решение остановиться на нём для дальнейшей разработки. 

Скорость расчётов и оптимизация кода особенно важна в данной работе, так как предполагается расчёт большого количества симуляций. Так, в программе была задействована технология OpenMP, позволяющая создавать многопоточные приложения. 
%%%
\subsection{Структура программы}
Программа состоит из класса ``Simulation'', представляющего собой модель одной симуляции, и ``оболочки'', которая необходимое количество раз повторяет объект-симуляцию с загружаемым в неё извне средним количеством струн $\langle N \rangle$. Само значение $\langle N \rangle$ находится из значения параметра $\langle \eta \rangle$ (средняя плотность струн) через соотношение 
\begin{equation} \label{eq:eta}
	\langle \eta \rangle = \frac{\langle N \rangle \sigma_0}{S},
\end{equation}
где $\sigma_0$ -- площадь одной струны, $\sigma_0 = \pi r_s^2$, где $r_s = 0.2 \div 0.3$ фм -- радиус струны; $S$ -- общая площадь взаимодействия в поперечном сечении ($S = \pi R^2$, тогда $R \approx 7.5$ фм -- радиус ядра, т.е. области взаимодействия; важно отметить, что такой способ определения площади взаимодействия используется только в решениях с равномерным разбросом струн). Так, для энергий RHIC значение $\langle \eta \rangle \approx 3$, а для LHC $\langle \eta \rangle \approx 11$ \cite{RHICandLHC}. Выбор значений $\sigma_0$ и $S$ требует некоторых отдельных пояснений. Во-первых, программа ``разбрасывает'' по факту не сами струны, а их центры, и тогда если центр струны ляжет на границу области взаимодействия, то часть струны будет внутри области, а часть -- снаружи. Тогда, в качестве $S$ следует принимать значение $S = \pi (R + r_s)^2$, где $R = 7.5$ фм и $r_s = 0.225$ фм фиксируются (выбор значения 0.225 объясняется тем, что при масштабировании $R$ до значения 1 значение $r_s$ масштабируется до 0.03). Во-вторых, в некоторых промежуточных тестовых стадиях разработки в качестве $S$ берётся суммарная площадь всех кластеров, так как в качестве функции плотности распределения координат струн выступает гауссиан.

Класс симуляции состоит из нескольких основных (см. листинг \ref{lst:SimulationMethodsGeneral} в приложении) и вспомогательных (листинг \ref{lst:SimulationMethodsAdd} в приложении) функций-методов. Каждый из основных методов класса выполняется один раз за симуляцию в соответствии с порядком в листинге. Описание данных методов следует ниже по порядку.
%%%
\subsubsection{Генерация струн}
Чтобы сгенерировать струны, изначально следует задать их количество $N$. Для проверки корректности работы программы на этапах 1-3 достаточно полагать $N = \langle N \rangle$, то есть от события к событию при наборе статистики для фиксированного $\langle \eta \rangle$ количество струн не меняется. Для расчёта $b$ (4 этап) решено генерировать $N$ с помощью распределения Пуассона с математическим ожиданием равным $\langle N \rangle$, что должно смоделировать реалистичный разброс $N$ от события к событию. 

В качестве функций плотности распределения (PDF) координат струн в зависимости от того или иного расчёта берётся равномерное непрерывное распределение в круге, или же более физичное гауссово распределение. 

Неравномерная генерация координат струн происходит методом Неймана как универсальным методом генерации значений случайной величины по любой функции плотности распределения (в перспективе -- использование в качестве PDF довольно сложный потенциал Вудса-Саксона, поэтому использование метода Неймана оправдано). Метод Неймана заключается в следующем: на брусе, полностью покрывающем носитель функции плотности распределения $f(x)$, равномерно разыгрывается число $A$; затем равномерно разыгрывается число $B$ от 0 до 1, и если $B < f(A)$, то $A$ утверждается как величина, распределённая по $f(x)$.
%%%
\subsubsection{Заполнение графа и нахождение компонент связности; поиск максимальной компоненты}
Граф пересечений струн представляет из себя симметричную матрицу $N \times N$, заполненную номерами струн, которые пересекаются со струной с номером соответствующей строки или столбца, либо нулевых элементов (в случае, если струна под номером столбца или строки не пересекается ни с какой другой). Факт пересечения двух струн равносилен тому, что расстояние между их центрами меньше либо равно двум радиусам одной струны $2r_s$ (проверяется с помощью 5-й вспомогательной функции из листинга \ref{lst:SimulationMethodsAdd} в приложении). 

Для определения кластеров ищутся компоненты связности графа. Здесь используется метод Depth-first search: в качестве первой компоненты связности берётся первая струна $s_1$, затем производится поиск пересечённых с ней струн $\{s'_i\}$ и берётся первая пересечённая струна $s'_1$, далее ищутся струны $\{s''_i\}$, пересечённые с $s'_1$, и так далее, пока пересечённых струн не останется (до $s^{(n)}_1$); эта же процедура проводится для $s^{(n-1)}_2$ и всех остальных из $\{s^{(n-1)}_i\}$, из $\{s^{(n-2)}_i\}$ и так далее до самой $s'_2$. Одновременно ``проверенные'' струны вычёркиваются из списка поиска, и следующая компонента связности ищется по струне $s_j$, где $j > 1$ -- первый номер струны, не вошедшей в первую компоненту. Проще говоря, каждую компоненту связности можно представить как куст, состоящий из веток, веток этих веток и т.д. до самых листьев, а метод Depth-first search -- счётчик узлов веток (листья тоже считаются узлом -- на поверхности). Если этот счётчик установить в каком-нибудь узле внутри куста, то он будет на каждом шаге стремиться к листьям, чтобы посчитать сначала узлы на поверхности, затем уйдёт на первый слой узлов, предшествующий листьям, потом на второй и далее до самого глубокого слоя, где остановится. Слово ``Depth'' в названии метода произошло из терминологии в теории графов: глубокими уровнями компоненты называются именно поверхностные уровни куста. Наглядная схема начала обхода небольшого графа представлена на рис. \ref{fig:DFS} в приложении. Помимо неё в приложении представлен код, реализующий алгоритм поиска компонент методом DFS (листинг \ref{lst:DFS}).

%%%
\subsubsection{Количество струн в кластере и его площадь}
Количество струн $N_k$ в кластере находится как длина массива компоненты связности, соответствующей данному кластеру. Таким образом, например, можно найти кластер с максимальным количеством струн $N_{cl}$, которым будет являться самый длинный массив из всех компонент связности -- данный приём понадобится для некоторых тестов программы на первых этапах разработки. 

Менее тривиальной задачей является вычисление площади кластера $S_k$. Здесь на помощь приходит метод Монте-Карло вычисления площадей фигуры произвольной формы: фигурой в данном случае является граничный контур наложенных друг на друга кругов-струн. Суть метода в следующем: на прямоугольник, покрывающий фигуру, разбрасывается сетка из точек, и тогда площадь фигуры примерно равна площади прямоугольника, помноженной на отношение количества попавших на фигуру точек к количеству не попавших.
%%%
\subsubsection{Генерация множественности вперёд-назад}
С помощью описынных выше методов сперва вычисляется площадь каждого кластера $S_k$ и количество струн в них $N_k$. Следуя \cite{MulReduction}, средняя множественность $\langle n \rangle_k$ для $k$-го кластера (как было отмечено ранее, рассматривается случай глобального слияния) в данном быстротном интервале вычисляется как 
\begin{equation} \label{eq:nkaverage}
	\langle n \rangle_k = \mu_0 \frac{S_k}{\sigma_0}\sqrt{l_k}, \quad l_k = \frac{N_k \sigma_0}{S_k},
\end{equation}
где $\sigma_0$ -- площадь одной струны, $\mu_0$ -- средняя множественность от одной струны в данном быстротном интервале. Для единичного интервала быстроты $\mu_0 = 1.1$ в соответствии с \cite{Mu0} (в дальнейших расчётах бралось $\mu_0 = 1$). Формулу \ref{eq:nkaverage} можно упростить до 
\begin{equation} \label{eq:nksimple}
	\langle n \rangle_k = \mu_0 \sqrt{\frac{N_k S_k}{\sigma_0}},
\end{equation}
подставив явно выражение для $l_k$ в выражение для $\langle n \rangle_k$.

Найденное значение $\langle n \rangle_k$ показывает лишь среднее число частиц, рождённых кластером $k$. Пусть в симуляции $i$ кластер $k$ имеет среднее значение множественности $\langle n \rangle_{ki}$. Для генерации значения множественности в переднем $n^F_{ki}$ и заднем $n^B_{ki}$ быстротных окнах используется распределение Пуассона с математическим ожиданием равным $\langle n \rangle_{ki}$. Таким образом, для каждого кластера получается своя выборка значений $n^F_{ki}$ и $n^B_{ki}$, эти выборки суммируются для каждого события 
\begin{equation} \label{eq:nfnb}
\begin{split}
	n^F_i = \sum_{k = 1}^{M_i} n^F_{ki}, \\
	n^B_i = \sum_{k = 1}^{M_i} n^B_{ki},
\end{split}
\end{equation}
где $n^F_i$ и $n^B_i$ -- FB множественности в событии $i$, $M_i$ -- количество кластеров в событии $i$. Стоит отметить, что, так как речь идёт о каком-то отдельном событии, данные вычисления проводятся для фиксированного параметра $\eta$, сгенерированного для данного события. 
%%%
\subsubsection{Генерация поперечного импульса вперёд-назад}
В соответствии с \cite{dissert} значения поперечного импульса генерируются не поочерёдно для каждого кластера, а сразу для всего события. Для этого необходимо знать вычисленные по описанной выше схеме значения $n^F_{ki}$ и $n^B_{ki}$. Тогда значения $(p_t)_i^F$, $(p_t)_i^B$ в соответствии с формулами 6.137-6.138 из \cite{dissert} распределены по гауссу, то есть функция распределения выглядит следующим образом (с точностью до замены F на B):
\begin{equation} \label{eq:pfpb}
\begin{split}
	f((p_t)_i^F) = \frac{1}{\sqrt{2\pi} \sigma_{(p_t)_i^F}} \exp{\left( - \frac{((p_t)_i^F - \overline{(p_t)_i^F})^2}{2(\sigma_{(p_t)_i^F})^2} \right)}, \\
	\overline{(p_t)_i^F} = \frac{\overline{p}}{n_i^F} \sum_{k = 1}^{M_i} n_k \sqrt[4]{\eta_k} = \overline{p} \cdot p_\Sigma, \qquad \quad \quad \\
	\sigma_{(p_t)_i^F}^2 = \frac{\sigma_p^2}{(n_i^F)^2} \sum_{k = 1}^{M_i} n_k \sqrt{\eta_k} = \sigma_p^2 \cdot \sigma_\Sigma^2, \quad \quad \quad
\end{split}
\end{equation}
где $\overline{(p_t)_i^F}$ и $\sigma_{(p_t)_i^F}$ -- среднее и дисперсия величины $(p_t)_i^F$; $\overline{p}$ и $\sigma_p^2$ -- некоторые константы, которые, согласно \cite{dissert}, связаны ссотношением $\sigma_p^2 = \gamma \overline{p}$, для расчётов бралось $\gamma = 1/\sqrt{2}$. Для расчётов корреляционного коэффициента $b$ можно не задавать явно $\overline{(p_t)_i^F}$ и $\sigma_{(p_t)_i^F}$, а достаточно преобразовать распределение \ref{eq:pfpb}, вынеся $\overline{(p_t)_i^F}$ и $\sigma_{(p_t)_i^F}$ из 
\begin{equation} \label{eq:pfpbBetter}
\begin{split}
	f \left( \frac{ (p_t)_i^F } { \overline{p} } \right) = \frac{1}{\sqrt{2 \pi} \sigma_p \sigma_\Sigma} \exp{ \left( - \frac{ \overline{p}^2 \left( \frac{ (p_t)_i^F }{ \overline{p} } - p_\Sigma \right)^2} { 2 \sigma_p^2 \sigma_\Sigma^2 } \right) } \Longrightarrow \\
	f \left( \frac{ (p_t)_i^F } { \overline{p} } \right) = \frac{1}{\sqrt{2 \pi} \sigma_p \sigma_\Sigma} \exp{ \left( - \frac{ \left( \frac{ (p_t)_i^F }{ \overline{p} } - p_\Sigma \right)^2} { 2 \gamma^2 \sigma_\Sigma^2 } \right) }, \quad \enspace \enspace
\end{split}
\end{equation}
и тогда можно задать только $\gamma$, так как при расчёте $b$, как будет описано далее, входит только частное статистически равных величин, распределённых по формуле \ref{eq:pfpbBetter}.
%%%
\subsubsection{Расчёт корреляционного коэффициента}
Выборки значений $\{ (n_F)_i \}$, $\{ (n_B)_i \}$, $\{ (p_F)_i \}$ и $\{ (p_B)_i \}$ непосредственно используются в расчёте $b$ с помощью вспомогательного метода 1 (см. листинг \ref{lst:SimulationMethodsAdd} в приложении). Для фиксированного $\langle \eta \rangle$ в соответствии с \cite{bStatement} величина $b$ находится как 
\begin{equation} \label{eq:nfnb}
\begin{split}
	b_{nn} = \frac{\langle n_F n_B \rangle - \langle n_F \rangle \langle n_B \rangle}{\langle n_F^2 \rangle - \langle n_F \rangle^2}, \\
	b_{p_tp_t} = \frac{\langle p_F p_B \rangle - \langle p_F \rangle \langle p_B \rangle}{\langle p_F^2 \rangle - \langle p_F \rangle^2},
\end{split}
\end{equation}
где усреднение происходит по всем симуляциям. 

