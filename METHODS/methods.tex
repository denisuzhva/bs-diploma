\section{Разработка генератора событий}
\subsection{План разработки и расчётов}
Для реализации генератора решено использовать объектно-ориентированный подход с целью обеспечить удобство дальнейших усовершенствований программы. В самой программе первоначально генерируется некоторое количество поперечных сечений струн в виде кругов фиксированного радиуса по заданному распределению (радиус струн соответствует параметрам распределения пропорционально реальному масштабу), затем производятся необходимые расчёты. Принципиальная схема работы программы представлена на рис. \ref{fig:DevSch} в приложении. Также в приложении (рис. \ref{fig:Strings}) представлена визуализация генерируемых струн. 

Для расчёта корреляций множественности и поперечного импульса адронов в переднем и заднем быстротных окнах (всюду далее величина корреляционного коэффицента будет обозначаться как $b$) необходимо сгенерировать соответственно значения множественности $n$ по сгенерированным струнами и значения поперечного имульса $p_t$ по струнной конфигурации и полученным значениям поперечного импульса. В качестве реализации учёта эффекта слияния струн $n$ и $p_t$ рассчитывается из плотности наложения (пересечения) струн друг на друга подсчётом количества струн в отдельно взятом кластере, а также подсчётом поперечной площади данного кластера (как наиболее физичное далее рассматриваться будет только глобальное слияние). 

Таким образом, разработка генератора разбивается на четыре этапа в порядке возрастания сложности, причём каждый следующий этап нуждается в завершённости предыдущих:
\begin{enumerate}[label=\arabic*.]
\item	Генерация струн.
\item	Поиск кластеров.
	\begin{enumerate}
	\item	Подсчёт количества струн в каждом кластере.
	\item	Вычисление площади каждого кластера.
	\end{enumerate}
\item	Генерация значений множественности и поперечного импульса.
\item	Расчёт FB корреляций множественности и поперечного импульса.
\end{enumerate}
%%%
\subsection{Выбор среды разработки}
Первоначально в качестве языка разработки был выбран MATLAB как очень удобный инструмент для быстрой и качественной реализации вычислительных алгоритмов. С помощью MATLAB были преодолены первые два этапа разработки, пока не был выявлен существенный недостаток данного решения -- слишком невысокая скорость расчётов по сравнению с более низкоуровневыми языками программирования, такими как C++ (приблизительно в 15-25 раз медленнее). На последнем впоследствии было заострено внимание, и далее было принято решение остановиться на нём для дальнейшей разработки. 

Скорость расчётов и оптимизация кода особенно важна в данной работе, так как предполагается расчёт большого количества симуляций. Так, в программе была задействована технология OpenMP, позволяющая создавать многопоточные приложения. 
%%%
\subsection{Структура программы}
Программа состоит из класса ``Simulation'', представляющего собой модель одной симуляции, и ``оболочки'', которая необходимое количество раз повторяет объект-симуляцию с загружаемым в неё извне средним количеством струн $\langle N \rangle$. Само значение $\langle N \rangle$ находится из значения параметра $\eta$ (средняя плотность струн, обозначается всюду далее без угловых скобок, так как сама по себе не является параметром для распределений) через соотношение 
\begin{equation} \label{eq:eta}
	\eta = \frac{\langle N \rangle \sigma_0}{S},
\end{equation}
где $\sigma_0$ -- площадь одной струны, $\sigma_0 = \pi r_s^2$, где $r_s = 0.2 \div 0.3$ фм -- радиус струны; $S$ -- общая площадь взаимодействия в поперечном сечении ($S = \pi R^2$, тогда $R \approx 7.5$ фм -- радиус ядра, т.е. области взаимодействия). Так, для энергий RHIC значение $\eta \approx 3$, а для LHC $\eta \approx 11$ \cite{RHICandLHC}. Выбор значений $\sigma_0$ и $S$ требует некоторых отдельных пояснений. Во-первых, программа ``разбрасывает'' по факту не сами струны, а их центры, и тогда если центр струны ляжет на границу области взаимодействия, то часть струны будет внутри области, а часть -- снаружи. Тогда, в качестве $S$ следует принимать значение $S = \pi (R + r_s)^2$, где $R = 7.5$ фм и $r_s = 0.225$ фм фиксируются (выбор значения 0.225 объясняется тем, что при масштабировании $R$ до значения 1 значение $r_s$ масштабируется до 0.03). Во-вторых, в некоторых промежуточных тестовых стадиях разработки в качестве $S$ берётся суммарная площадь всех кластеров, так как в качестве функции плотности распределения координат струн выступает гауссиан.

Класс симуляции состоит из нескольких основных (см. листинг \ref{lst:SimulationMethodsGeneral} в приложении) и вспомогательных (листинг \ref{lst:SimulationMethodsAdd} в приложении) функций-методов. Каждый из основных методов класса выполняется один раз за симуляцию в соответствии с порядком в листинге. Описание данных методов следует ниже по порядку.
%%%
\subsubsection{Генерация струн}
Чтобы сгенерировать струны, изначально следует задать их количество $N$. Для расчёта $b$ (4 этап) решено генерировать $N$ с помощью равномерного дискретного распределения с математическим ожиданием равным $\langle N \rangle$ на промежутке от 0 до $2N$ (в предыдущих этапах в качестве $N$ бралось непосредственно значение $\langle N \rangle$). 

В качестве функций плотности распределения (PDF) координат струн первоначально бралось равномерное непрерывное распределение в круге, затем более физичное гауссово распределение. Для этапа расчёта корреляций используется отражённая по оси $z$ трёхмерная парабола
\begin{equation} \label{eq:parabolaPDF}
	z = -x^2 - y^2 + 1
\end{equation}
как хорошее приближение гауссиана в интересующей области. 

Генерация координат струн происходит методом Неймана как универсальным методом генерации значений случайной величины по любой функции плотности распределения (в перспективе -- использование в качестве PDF довольно сложный потенциал Вудса-Саксона, поэтому использование метода Неймана оправдано). Метод Неймана заключается в следующем: на брусе, полностью покрывающем носитель функции плотности распределения $f(x)$, равномерно разыгрывается число $A$; затем равномерно разыгрывается число $B$ от 0 до 1, и если $B < f(A)$, то $A$ утверждается как величина, распределённая по $f(x)$.
%%%
\subsubsection{Заполнение графа и нахождение компонент связности; поиск максимальной компоненты}
Граф пересечений струн представляет из себя симметричную матрицу $N \times N$, заполненную номерами струн, которые пересекаются со струной с номером соответствующей строки или столбца, либо нулевых элементов (в случае, если струна под номером столбца или строки не пересекается ни с какой другой). Факт пересечения двух струн равносилен тому, что расстояние между их центрами меньше либо равно двум радиусам одной струны $2r_s$ (проверяется с помощью 5-й вспомогательной функции из листинга \ref{lst:SimulationMethodsAdd} в приложении). 

Для определения кластеров ищутся компоненты связности графа. Здесь используется метод Depth-first search: в качестве первой компоненты связности берётся первая струна $s_1$, затем производится поиск пересечённых с ней струн $\{s'_i\}$ и берётся первая пересечённая струна $s'_1$, далее ищутся струны $\{s''_i\}$, пересечённые с $s'_1$, и так далее, пока пересечённых струн не останется (до $s^{(n)}_1$); эта же процедура проводится для $s^{(n-1)}_2$ и всех остальных из $\{s^{(n-1)}_i\}$, из $\{s^{(n-2)}_i\}$ и так далее до самой $s'_2$. Одновременно ``проверенные'' струны вычёркиваются из списка поиска, и следующая компонента связности ищется по струне $s_j$, где $j > 1$ -- первый номер струны, не вошедшей в первую компоненту. Проще говоря, каждую компоненту связности можно представить как куст, состоящий из веток, веток этих веток и т.д. до самых листьев, а метод Depth-first search -- счётчик узлов веток (листья тоже считаются узлом -- на поверхности). Если этот счётчик установить в каком-нибудь узле внутри куста, то он будет на каждом шаге стремиться к листьям, чтобы посчитать сначала узлы на поверхности, затем уйдёт на первый слой узлов, предшествующий листьям, потом на второй и далее до самого глубокого слоя, где остановится. Слово ``Depth'' в названии метода произошло из терминологии в теории графов: глубокими уровнями компоненты называются именно поверхностные уровни куста. Наглядная схема начала обхода небольшого графа представлена на рис. \ref{fig:DFS} в приложении. Помимо неё в приложении представлен код, реализующий алгоритм поиска компонент методом DFS (листинг \ref{lst:DFS})

Максимальная компонента связности находится из полученного набора компонент как самая длинная, т.е. имеющая больше всего струн. Отыскание максимальной компоненты связности означает нахождение максимального кластера -- нужного для проверки корректности работы программы.
%%%
\subsubsection{Количество струн в максимальном кластере и его площадь}
Зная номер максимальной компоненты связности, нетрудно вычислить количество струн $N_{cl}$ в соответствующем кластере: оно равно длине массива (вектора) компоненты, так как этот массив хранит номера всех струн из кластера. 

Менее тривиальной задачей является вычисление площади кластера. Здесь на помощь приходит метод Монте-Карло вычисления площадей фигуры произвольной формы: фигурой в данном случае является граничный контур наложенных друг на друга кругов-струн. Суть метода в следующем: на прямоугольник или круг, покрывающий фигуру, разбрасывается сетка из точек, и тогда площадь фигуры примерно равна площади прямоугольника, помноженной на отношение количества попавших на фигуру точек к количеству не попавших.
%%%
\subsubsection{Генерация множественности вперёд-назад}
С помощью описынных выше методов сперва вычисляется площадь каждого кластера $S_k$ и количество струн в них $N_k$. Следуя \cite{MulReduction}, средняя множественность $\langle n \rangle_k$ для $k$-го кластера (глобальное слияние) в данном быстротном интервале вычисляется как 
\begin{equation} \label{eq:nkaverage}
	\langle n \rangle_k = \mu_0 \frac{S_k}{\sigma_0}\sqrt{l_k}, \quad l_k = \frac{N_k \sigma_0}{S_k},
\end{equation}
где $\sigma_0$ -- площадь одной струны, $\mu_0$ -- средняя множественность от одной струны в данном быстротном интервале. Для единичного интервала быстроты $\mu_0 = 1.1$ в соответствии с \cite{Mu0} (в дальнейших расчётах бралось $\mu_0 = 1$). Формулу \ref{eq:nkaverage} можно упростить до 
\begin{equation} \label{eq:nksimple}
	\langle n \rangle_k = \mu_0 \sqrt{\frac{N_k S_k}{\sigma_0}},
\end{equation}
подставив явно выражение для $l_k$ в выражение для $\langle n \rangle_k$.

Найденное значение $\langle n \rangle_k$ показывает лишь среднее число частиц, рождённых кластером $k$. Пусть в симуляции $i$ кластер $k$ имеет среднее значение множественности $\langle n \rangle_{ki}$. Для генерации значения множественности в переднем $n^F_{ki}$ и заднем $n^B_{ki}$ быстротных окнах используется распределение Пуассона с математическим ожиданием равным $\langle n \rangle_{ki}$. Таким образом, для каждого кластера получается своя выборка значений $n^F_{ki}$ и $n^B_{ki}$, эти выборки суммируются для каждого события 
\begin{equation} \label{eq:nfnb}
\begin{split}
	n^F_i = \sum_{k = 1}^{M_i} n^F_{ki}, \\
	n^B_i = \sum_{k = 1}^{M_i} n^B_{ki},
\end{split}
\end{equation}
где $n^F_i$ и $n^B_i$ -- FB множественности в событии $i$, $M_i$ -- количество кластеров в событии $i$. Стоит отметить, что данные выкладки проводятся для фиксированного параметра $\eta$. 
%%%
\subsection{Внутрипрограммный расчёт корреляционного коэффициента}
Выборки значений $\{ (n_F)_i \}$ и $\{ (n_B)_i \}$ непосредственно используются в расчёте $b$ с помощью вспомогательного метода 1 (см. листинг \ref{lst:SimulationMethodsAdd} в приложении). Для фиксированного $\eta$ в соответствии с \cite{bStatement} величина $b$ находится как 
\begin{equation} \label{eq:nfnb}
	b = \frac{\langle n_F n_B \rangle - \langle n_F \rangle \langle n_B \rangle}{\langle n_F^2 \rangle - \langle n_F \rangle^2},
\end{equation}
усреднение происходит по всем симуляциям. Данный расчёт в самой программе удобен лишь для оценки правильности её работы, потому как часто для увеличения выборки приходится использовать данные с симуляций, рассчитанные на нескольких машинах (распределённые вычисления на данный момент не реализованы).